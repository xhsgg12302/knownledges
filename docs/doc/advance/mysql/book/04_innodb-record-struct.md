## 准备工作
?> 到现在为止， MySQL 对于我们来说还是一个黑盒，我们只负责使用客户端发送请求并等待服务器返回结果，表中
的数据到底存到了哪里？以什么格式存放的？ MySQL 是以什么方式来访问的这些数据？我们前边唠叨请求处理过程的时候提到过， MySQL 服务器上负责对表中数据的读取和写入工作的部分是 存储引擎 ，而服务器又支持不同类型的存储引擎，比如 InnoDB 、 MyISAM 、 Memory 啥的，不同的存储引擎一般是由不同的人为实现不同的特性而开发的，真实数据在不同存储引擎中存放的格式一般是不同的，甚至有的存储引擎比如 Memory 都不用磁盘来存储数据，也就是说关闭服务器后表中的数据就消失了。由于 InnoDB 是 MySQL 默认的存储引擎，也是我们最常用到的存储引擎，我们也没有那么多时间去把各个存储引擎的内部实现都看一遍，所以本集要唠叨的是使用 InnoDB 作为存储引擎的数据存储结构。

## InnoDB页简介
?> InnoDB 是一个将表中的数据存储到磁盘上的存储引擎，所以即使关机后重启我们的数据还是存在的。而真正处理数据的过程是发生在内存中的，所以需要把磁盘中的数据加载到内存中，如果是处理写入或修改请求的话，还需要把内存中的内容刷新到磁盘上。而我们知道读写磁盘的速度非常慢，和内存读写差了几个数量级，所以当我们想从表中获取某些记录时， InnoDB 存储引擎需要一条一条的把记录从磁盘上读出来么？不，那样会慢死，InnoDB 采取的方式是：将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般为 16 KB。也就是在一般情况下，一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。

* ## InnoDB行格式
?> 我们平时是以记录为单位来向表中插入数据的，这些记录在磁盘上的存放方式也被称为 行格式 或者 记录格式 。设计 InnoDB 存储引擎的大叔们到现在为止设计了4种不同类型的 行格式 ，分别是 Compact 、 Redundant 、Dynamic 和 Compressed 行格式，随着时间的推移，他们可能会设计出更多的行格式，但是不管怎么变，在原理上大体都是相同的。

    1. ### 指定行格式的语法

        我们可以在创建或修改表的语句中指定 行格式 ： `CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称` `ALTER TABLE 表名 ROW_FORMAT=行格式名称`

        ```sql
        # 比如我们在 myemployees 数据库里创建一个演示用的表 `record_format_demo`，可以这样指定它的 行格式：
        USE myemployees;

        CREATE TABLE record_format_demo (
            c1 VARCHAR(10),
            c2 VARCHAR(10) NOT NULL,
            c3 CHAR(10),
            c4 VARCHAR(10)
        ) CHARSET=ascii ROW_FORMAT=COMPACT;

        # 可以看到我们刚刚创建的这个表的 行格式 就是 Compact ，另外，我们还显式指定了这个表的字符集为 ascii ，
        # 因为 ascii 字符集只包括空格、标点符号、数字、大小写字母和一些不可见字符，所以我们的汉字是不能存到这
        # 个表里的。我们现在向这个表中插入两条记录：
        INSERT INTO record_format_demo(c1, c2, c3, c4) VALUES('aaaa', 'bbb', 'cc', 'd'),('eeee', 'fff', NULL, NULL);
        ```
        现在表中的记录就是这个样子的：

        ![](/.images/doc/advance/mysql/book/04_innodb_record_struct/irs-01.png ':size=48%')
        ![](/.images/doc/advance/mysql/book/04_innodb_record_struct/irs-02.png ':size=45%')
        ![](/.images/doc/advance/mysql/book/04_innodb_record_struct/irs-03.png ':size=48%')
        ![](/.images/doc/advance/mysql/book/04_innodb_record_struct/irs-04.png ':size=41%')
    
    2. ### COMPACT行格式
    ?> 大家从图中可以看出来，一条完整的记录其实可以被分为 **记录的额外信息** 和 **记录的真实数据** 两大部分，下边我们详细看一下这两部分的组成。

        ![](/.images/doc/advance/mysql/book/04_innodb_record_struct/irs-05.png ':size=80%')

        * #### 记录的额外信息

            ?> 这部分信息是服务器为了描述这条记录而不得不额外添加的一些信息，这些额外信息分为3类，分别是 变长字段长度列表 、 NULL值列表 和 记录头信息 ，我们分别看一下。

            + **变长字段长度列表**

                - 正文

                    我们知道 MySQL 支持一些变长的数据类型，比如 VARCHAR(M) 、 VARBINARY(M) 、各种 TEXT 类型，各种 BLOB 类型，我们也可以把拥有这些数据类型的列称为 变长字段 ，变长字段中存储多少字节的数据是不固定的，所以我们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来，这样才不至于把 MySQL 服务器搞懵，所以这些变长字段占用的存储空间分为两部分：

                    `1.真正的数据内容`
                    <br>`2.占用的字节数`
                    
                    在 Compact 行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表，各变长字段数据占用的字节数按照列的顺序逆序存放，我们再次强调一遍，是`逆序存放`！我们拿 record_format_demo 表中的第一条记录来举个例子。因为 record_format_demo 表的 c1 、 c2 、 c4 列都是 VARCHAR(10) 类型的，也就是变长的数据类型，所以这三个列的值的长度都需要保存在记录开头处，因为record_format_demo 表中的各个列都使用的是 ascii 字符集，所以每个字符只需要1个字节来进行编码，来看一下第一条记录各变长字段内容的长度：

                    | 列名 | 存储内容 | 内容长度（十进制表示）| 内容长度（十六进制表示）|
                    | - | - | - | - |
                    | c1 | 'aaaa'   | 4 | 0x04 |
                    | c2 | 'bbb'    | 3 | 0x03 |
                    | c4 | 'd'      |1  | 0x01 |

                    又因为这些长度值需要按照列的逆序存放，所以最后 变长字段长度列表 的字节串用十六进制表示的效果就是（用空格隔开只是方便理解）：
                    <br>**01 03 04**
                    <br>把这个字节串组成的 变长字段长度列表 填入上边的示意图中的效果就是：
                    
                    ![](/.images/doc/advance/mysql/book/04_innodb_record_struct/irs-06.png ':size=80%')

                    由于第一行记录中 c1 、 c2 、 c4 列中的字符串都比较短，也就是说内容占用的字节数比较小，用1个字节就可以表示，但是如果变长列的内容占用的字节数比较多，可能就需要用2个字节来表示。具体用1个还是2个字节来表示真实数据占用的字节数， InnoDB 有它的一套规则，我们首先声明一下 W 、 M 和 L 的意思：

                    1. 假设某个字符集中表示一个字符最多需要使用的字节数为 W ，也就是使用 SHOW CHARSET 语句的结果中的Maxlen 列，比方说 utf8 字符集中的 W 就是 3 ， gbk 字符集中的 W 就是 2 ， ascii 字符集中的 W 就是1 。
                    2. 对于变长类型 VARCHAR(M) 来说，这种类型表示能存储最多 M 个字符（注意是字符不是字节），所以这个类型能表示的字符串最多占用的字节数就是 M×W 。
                    3. 假设它实际存储的字符串占用的字节数是 L 。所以确定使用1个字节还是2个字节表示真正字符串占用的字节数的规则就是这样：
                        - 如果 M×W <= 255 ，那么使用1个字节来表示真正字符串占用的字节数。

                            ?> 也就是说InnoDB在读记录的变长字段长度列表时先查看表结构，如果某个变长字段允许存储的最大字节数不大于255时，可以认为只使用1个字节来表示真正字符串占用的字节数。
                        - 如果 M×W > 255 ，则分为两种情况：
                            + 如果 L <= 127 ，则用1个字节来表示真正字符串占用的字节数。
                            + 如果 L > 127 ，则用2个字节来表示真正字符串占用的字节数。
                        
                        ?> InnoDB在读记录的变长字段长度列表时先查看表结构，如果某个变长字段允许存储的最大字节数大于255时，该怎么区分它正在读的某个字节是一个单独的字段长度还是半个字段长度呢？设计InnoDB的大叔使用该字节的第一个二进制位作为标志位：如果该字节的第一个位为0，那该字节就是一个单独的字段长度（使用一个字节表示不大于127的二进制的第一个位都为0），如果该字节的第一个位为1，那该字节就是半个字段长度。
                        <br>对于一些占用字节数非常多的字段，比方说某个字段长度大于了16KB，那么如果该记录在单个页面中无法存储时，InnoDB会把一部分数据存放到所谓的溢出页中（我们后边会唠叨），在变长字段长度列表处只存储留在本页面中的长度，所以使用两个字节也可以存放下来。
                    
                - 总结

                    总结一下就是说：如果该可变字段允许存储的最大字节数（ M×W ）超过255字节并且真实存储的字节数（ L ）超过127字节，则使用2个字节，否则使用1个字节。另外需要注意的一点是，`变长字段长度列表中只存储值为 非NULL 的列内容占用的长度，值为 NULL 的列的长度是不储存的`。也就是说对于第二条记录来说，因为 c4 列的值为 NULL ，所以第二条记录的 变长字段长度列表 只需要存储 c1 和 c2 列的长度即可。其中 c1 列存储的值为 'eeee' ，占用的字节数为 4 ， c2 列存储的值为 'fff' ，占用的字节数为 3 。数字 4 可以用1个字节表示， 3 也可以用1个字节表示，所以整个 变长字段长度列表 共需2个字节。填充完 变长字段长度列表 的两条记录的对比图如下：

                    ![](/.images/doc/advance/mysql/book/04_innodb_record_struct/irs-07.png ':size=80%')

                    !> 并不是所有记录都有这个 变长字段长度列表 部分，比方说表中所有的列都不是变长的数据类型的话，这一部分就不需要有。
                
            + **NULL值列表**

        * #### 记录的真实数据


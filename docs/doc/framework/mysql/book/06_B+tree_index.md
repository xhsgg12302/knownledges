> [!NOTE]前边我们详细唠叨了 InnoDB 数据页的7个组成部分，知道了各个数据页可以组成一个 双向链表 ，而每个数据页中的记录会按照主键值从小到大的顺序组成一个 单向链表 ，每个数据页都会为存储在它里边儿的记录生成一个页目录 ，在通过主键查找某条记录的时候可以在 页目录 中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录（如果你对这段话有一丁点儿疑惑，那么接下来的部分不适合你，返回去看一下数据页结构吧）。页和记录的关系示意图如下：
<br><br>其中页a、页b、页c ... 页n 这些页可以不在物理结构上相连，只要通过双向链表相关联即可。

![](/.images/doc/framework/mysql/book/06_B+tree_index/bti-01.png ':size=90% :align=center')

* ## 没有索引的查找

    ?> 本集的主题是 索引 ，在正式介绍 索引 之前，我们需要了解一下没有索引的时候是怎么查找记录的。为了方便大家理解，我们下边先只唠叨搜索条件为对某个列精确匹配的情况，所谓精确匹配，就是搜索条件中用等于 = 连接起的表达式，比如这样：
    <br>`SELECT [列名列表] FROM 表名 WHERE 列名 = xxx;`
    + ### 在一个页中的查找

        > [!NOTE]假设目前表中的记录比较少，所有的记录都可以被存放到一个页中，在查找记录的时候可以根据搜索条件的不同分为两种情况：
        <br>1. `以主键为搜索条件`: 这个查找过程我们已经很熟悉了，可以在 页目录 中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。
        <br>2. `以其他列作为搜索条件`: 对非主键列的查找的过程可就不这么幸运了，因为在数据页中并没有对非主键列建立所谓的 页目录 ，所以我们无法通过二分法快速定位相应的 槽 。这种情况下只能从 最小记录 开始依次遍历单链表中的每条记录，然后对比每条记录是不是符合搜索条件。很显然，这种查找的效率是非常低的。

    + ### 在很多页中查找

        > [!NOTE]大部分情况下我们表中存放的记录都是非常多的，需要好多的数据页来存储这些记录。在很多页中查找记录的话可以分为两个步骤：
        <br>`1). ` 定位到记录所在的页。
        <br>`2). ` 从所在的页内中查找相应的记录。
        <br><br>在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，<span style='color: blue'>由于我们并不能快速的定位到记录所在的页，所以只能从第一个页沿着双向链表一直往下找，在每一个页中根据我们刚刚唠叨过的查找方式去查找指定的记录</span>。因为要遍历所有的数据页，所以这种方式显然是超级耗时的，如果一个表有一亿条记录，使用这种方式去查找记录那要等到猴年马月才能等到查找结果。所以祖国和人民都在期盼一种能高效完成搜索的方法， 索引 同志就要亮相登台了。

* ## 索引

    ?> 为了故事的顺利发展，我们先建一个表：` CREATE TABLE index_demo( c1 INT, c2 INT, c3 CHAR(1), PRIMARY KEY(c1) ) ROW_FORMAT = Compact;`
    <br>这个新建的 index_demo 表中有2个 INT 类型的列，1个 CHAR(1) 类型的列，而且我们规定了 c1 列为主键，这个表使用 Compact 行格式来实际存储记录的。为了我们理解上的方便，我们简化了一下 index_demo 表的行格式示意图：

    <!-- panels:start -->
    <!-- div:left-panel-50 -->
    ?> 我们只在示意图里展示记录的这几个部分：
    <br><br>`1). `: `record_type` ：记录头信息的一项属性，表示记录的类型，0 表示普通记录、2 表示最小记录、3 表示最大记录、1 我们还没用过，等会再说～
    <br>`2). `: `next_record` ：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，为了方便大家理解，我们都会用箭头来表明下一条记录是谁。
    <br>`3). `: `各个列的值` ：这里只记录在 index_demo 表中的三个列，分别是 c1 、 c2 和 c3 。
    <br>`4). `: `其他信息` ：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。
    <!-- div:right-panel-50 -->
    ![](/.images/doc/framework/mysql/book/06_B+tree_index/bti-02.png ':size=100%')
    <!-- panels:end -->

    ?> 为了节省篇幅，我们之后的示意图中会把记录的 其他信息 这个部分省略掉，因为它占地方并且不会有什么观赏效果。另外，为了方便理解，我们觉得把记录竖着放看起来感觉更好，所以将记录格式示意图的 其他信息 去掉并把它竖起来的效果就是图一这样：
    <br><br>把一些记录放到页里边的示意图就是图二：

    ![](/.images/doc/framework/mysql/book/06_B+tree_index/bti-03.png ':size=49%')
    ![](/.images/doc/framework/mysql/book/06_B+tree_index/bti-04.png ':size=49%')

    + ### 一个简单的索引方案

        ?> 回到正题，我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以 不得不 依次遍历所有的数据页。所以如果我们想快速的定位到需要查找的记录在哪些数据页中该咋办？还记得我们为根据主键值快速定位一条记录在页中的位置而设立的页目录么？我们也可以想办法为快速定位记录所在的数据页而建立一个别的目录，建这个目录必须完成下边这些事儿：

        1. **下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值**

            <!-- panels:start -->
            <!-- div:left-panel-60 -->
            > [!NOTE]为了故事的顺利发展，我们这里需要做一个假设：假设我们的每个数据页最多能存放3条记录（实际上一个数据页非常大，可以存放下好多记录）。有了这个假设之后我们向 index_demo 表插入3条记录：
            <br>`INSERT INTO index_demo VALUES(1, 4, 'u'), (3, 9, 'd'), (5, 3, 'y');`
            <br><br>那么这些记录已经按照主键值的大小串联成一个单向链表了，如图所示：
            <!-- div:right-panel-40 -->
            ![](/.images/doc/framework/mysql/book/06_B+tree_index/bti-05.png ':size=100%')
            <!-- panels:end -->

            <!-- panels:start -->
            <!-- div:left-panel-40 -->
            > [!NOTE]从图中可以看出来， index_demo 表中的3条记录都被插入到了编号为 10 的数据页中了。此时我们再来插入一条记录：
            <br>`INSERT INTO index_demo VALUES(4, 4, 'a');`
            <br><br>因为 页10 最多只能放3条记录，所以我们不得不再分配一个新页：
            <!-- div:right-panel-60 -->
            ![](/.images/doc/framework/mysql/book/06_B+tree_index/bti-06.png ':size=100%')
            <!-- panels:end -->

            <!-- panels:start -->
            <!-- div:left-panel-40 -->
            > [!NOTE]咦？怎么分配的页号是 28 呀，不应该是 11 么？再次强调一遍，新分配的数据页编号可能并不是连续的，也就是说我们使用的这些页在存储空间里可能并不挨着。它们只是通过维护着上一个页和下一个页的编号而建立了链表关系。另外， 页10 中用户记录最大的主键值是 5 ，而 页28 中有一条记录的主键值是 4 ，因为 5 > 4 ，所以这就不符合下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值的要求，所以在插入主键值为 4 的记录的时候需要伴随着一次记录移动，也就是把主键值为 5 的记录移动到 页28 中，然后再把主键值为 4 的记录插入到 页10 中，这个过程的示意图如右：
            <br><br>这个过程表明了在对页中的记录进行增删改操作的过程中，我们必须通过一些诸如记录移动的操作来始终保证这个状态一直成立：下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。这个过程我们也可以称为`页分裂`。
            <!-- div:right-panel-60 -->
            ![](/.images/doc/framework/mysql/book/06_B+tree_index/bti-07.png ':size=100%')
            <!-- panels:end -->

        2. **给所有的页建立一个目录项**

            ?> 由于数据页的编号可能并不是连续的，所以在向 index_demo 表中插入许多条记录后，可能是这样的效果：

            ![](/.images/doc/framework/mysql/book/06_B+tree_index/bti-08.png ':size=80% :align=center')

            ?> 因为这些 16KB 的页在物理存储上可能并不挨着，所以如果想从这么多页中根据主键值快速定位某些记录所在的页，我们需要给它们做个目录，每个页对应一个目录项，每个目录项包括下边两个部分：
            <br>`1). `: 页的用户记录中最小的主键值，我们用 key 来表示。
            <br>`2). `: 页号，我们用 page_no 表示。所以我们为上边几个页做好的目录就像下图这样子：
            <br><br>以 页28 为例，它对应 目录项2 ，这个目录项中包含着该页的页号 28 以及该页中用户记录的最小主键值 5 。我们只需要把几个目录项在物理存储器上连续存储，比如把他们放到一个数组里，就可以实现根据主键值快速查找某条记录的功能了。比方说我们想找主键值为 20 的记录，具体查找过程分两步：
            <br>`a). `: 先从目录项中根据二分法快速确定出主键值为 20 的记录在 目录项3 中（因为 12 < 20 < 209 ），它对应的页是 页9 。
            <br>`b). `: 再根据前边说的在页中查找记录的方式去 页9 中定位具体的记录。

            ![](/.images/doc/framework/mysql/book/06_B+tree_index/bti-09.png ':size=80% :align=center')

    
        > [!ATTENTION]至此，针对数据页做的简易目录就搞定了。不过忘了说了，<span style='color: blue'>这个**目录**有一个别名，称为`索引`</span>。

    + ### InnoDB中的索引方案
    + ### InnoDB的B+树索引的注意事项
    + ### MyISAM中的索引方案简单介绍
    + ### MySQL中创建和删除索引的语句
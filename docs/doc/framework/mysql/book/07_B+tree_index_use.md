> [!NOTE] 我们前边详细、详细又详细的唠叨了 InnoDB 存储引擎的 B+ 树索引，我们必须熟悉下边这些结论：
<br>`1).` 每个索引都对应一棵B+树，B+树分为好多层，最下边一层是叶子节点，其余的是内节点。所有**用户记录**都存储在B+树的叶子节点，所有**目录项记录**都存储在内节点。
<br>`2).` InnoDB 存储引擎会自动为主键（如果没有它会自动帮我们添加）建立**聚簇索引**，聚簇索引的叶子节点包含完整的用户记录。
<br>`3).` 我们可以为自己感兴趣的列建立**二级索引**，二级索引的叶子节点包含的用户记录由**索引列+主键**组成，所以如果想通过**二级索引**来查找完整的用户记录的话，需要通过**回表**操作，也就是在通过二级索引找到主键值之后再到**聚簇索引**中查找完整的用户记录。
<br>`4).` B+ 树中每层节点都是按照索引列值从小到大的顺序排序而组成了双向链表，而且每个页内的记录（不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单链表。如果是**联合索引**的话，则页面和记录先按照**联合索引**前边的列排序，如果该列值相同，再按照**联合索引**后边的列排序。
<br>`5).` 通过索引查找记录是从 B+ 树的根节点开始，一层一层向下搜索。由于每个页面都按照索引列的值建立了Page Directory （页目录），所以在这些页面中的查找非常快。
<br><br>如果你读上边的几点结论有些任何一点点疑惑的话，那下边的内容不适合你，回过头先去看前边的内容去。

* ## 索引的代价

    > [?] 在熟悉了 B+ 树索引原理之后，本篇文章的主题是唠叨如何更好的使用索引，虽然索引是个好东西，可不能乱建，在介绍如何更好的使用索引之前先要了解一下使用这玩意儿的代价，它在空间和时间上都会拖后腿：
    <br>`空间上的代价`：这个是显而易见的，每建立一个索引都要为它建立一棵 B+ 树，每一棵 B+ 树的每一个节点都是一个数据页，一个页默认会占用 16KB 的存储空间，一棵很大的 B+ 树由许多数据页组成，那可是很大的一片存储空间呢。
    <br>`时间上的代价`：每次对表中的数据进行增、删、改操作时，都需要去修改各个 B+ 树索引。而且我们讲过， B+ 树每层节点都是按照索引列的值从小到大的顺序排序而组成了双向链表。不论是叶子节点中的记录，还是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些记录移位，页面分裂、页面回收啥的操作来维护好节点和记录的排序。如果我们建了许多索引，每个索引对应的 B+ 树都要进行相关的维护操作，这还能不给性能拖后腿么？
    <br><br>所以说，一个表上索引建的越多，就会占用越多的存储空间，在增删改记录的时候性能就越差。为了能建立又好又少的索引，我们先得学学这些索引在哪些条件下起作用的。

* ## B+树索引适用的条件

    > [?] 下边我们将唠叨许多种让 B+ 树索引发挥最大效能的技巧和注意事项，不过大家要清楚，所有的技巧都是源自你对 B+ 树索引本质的理解，所以如果你还不能保证对 B+ 树索引充分的理解，那么再次建议回过头把前边的内容看完了再来，要不然读文章对你来说是一种折磨。首先， B+ 树索引并不是万能的，并不是所有的查询语句都能用到我们建立的索引。下边介绍几个我们可能使用 B+ 树索引来进行查询的情况。为了故事的顺利发展，我们需要先创建一个表，这个表是用来存储人的一些基本信息的：
    <br>`CREATE TABLE person_info( id INT NOT NULL auto_increment, name VARCHAR(100) NOT NULL, birthday DATE NOT NULL,phone_number CHAR(11) NOT NULL, country varchar(100) NOT NULL, PRIMARY KEY (id), KEY idx_name_birthday_phone_number (name, birthday, phone_number) );`
    <br><br>对于这个 person_info 表我们需要注意两点：
    <br>`1).` 表中的主键是 id 列，它存储一个自动递增的整数。所以 InnoDB 存储引擎会自动为 id 列建立聚簇索引。
    <br>`2).` 我们额外定义了一个二级索引 idx_name_birthday_phone_number ，它是由3个列组成的联合索引。所以在这个索引对应的 B+ 树的叶子节点处存储的用户记录只保留 name 、 birthday 、 phone_number 这三个列的值以及主键 id 的值，并不会保存 country 列的值。
    <br><br>从这两点注意中我们可以再次看到，一个表中有多少索引就会建立多少棵 B+ 树， person_info 表会为聚簇索引和 idx_name_birthday_phone_number 索引建立2棵 B+ 树。下边我们画一下索引idx_name_birthday_phone_number 的示意图，不过既然我们已经掌握了 InnoDB 的 B+ 树索引原理，那我们在画图的时候为了让图更加清晰，所以在省略一些不必要的部分，比如记录的额外信息，各页面的页号等等，其中内节点中目录项记录的页号信息我们用箭头来代替，在记录结构中只保留 name 、 birthday 、 phone_number 、id 这四个列的真实数据值，所以示意图就长这样（留心的同学看出来了，这其实和《高性能MySQL》里举的例子的图差不多，我觉得这个例子特别好，所以就借鉴了一下）：

    ![](/.images/doc/framework/mysql/book/07_B+tree_index_ues/btiu-01.png ':size=90% :align=center')

    > [?] 为了方便大家理解，我们特意标明了哪些是内节点，哪些是叶子节点。再次强调一下，内节点中存储的是 目录项记录 ，叶子节点中存储的是 用户记录 （由于不是聚簇索引，所以用户记录是不完整的，缺少 country 列的值）。从图中可以看出，这个 idx_name_birthday_phone_number 索引对应的 B+ 树中页面和记录的排序方式就是这样的：
    <br>`1)` 先按照 name 列的值进行排序。
    <br>`2)` 如果 name 列的值相同，则按照 birthday 列的值进行排序。
    <br>`3)` 如果 birthday 列的值也相同，则按照 phone_number 的值进行排序。
    <br><br>这个排序方式<span style='color: blue'>十分、特别、非常、巨、very very very重要，因为只要页面和记录是排好序的，我们就可以通过二分法来快速定位查找</span>。下边的内容都仰仗这个图了，大家对照着图理解。

    + ### 1.全值匹配

        > [?] 如果我们的搜索条件中的列和索引列一致的话，这种情况就称为全值匹配，比方说下边这个查找语句：
        <br>`SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday = '1990-09-27' AND phone_number = '15123983239';`
        <br><br>我们建立的 idx_name_birthday_phone_number 索引包含的3个列在这个查询语句中都展现出来了。大家可以想象一下这个查询过程：
        <br>`1)` 因为 B+ 树的数据页和记录先是按照 name 列的值进行排序的，所以先可以很快定位 name 列的值是 Ashburn的记录位置。
        <br>`2)` 在 name 列相同的记录里又是按照 birthday 列的值进行排序的，所以在 name 列的值是 Ashburn 的记录里又可以快速定位 birthday 列的值是 '1990-09-27' 的记录。
        <br>`3)` 如果很不幸， name 和 birthday 列的值都是相同的，那记录是按照 phone_number 列的值排序的，所以联合索引中的三个列都可能被用到。
        <br><br>有同学也许有个疑问，WHERE子句中的几个搜索条件的顺序对查询结果有啥影响么？也就是说如果我们调换name、birthday、phone_number这几个搜索列的顺序对查询的执行过程有影响么？比方说写成下边这样：
        <br>`SELECT * FROM person_info WHERE birthday = '1990-09-27' AND phone_number = '15123983239' AND name = 'Ashburn';`
        <br><br>答案是：没影响哈。 MySQL 有一个叫查询优化器的东东，会分析这些搜索条件并且按照可以使用的索引中列的顺序来决定先使用哪个搜索条件，后使用哪个搜索条件。我们后边儿会有专门的章节来介绍查询优化器，敬请期待。

    + ### 2.匹配左边的列

        > [?] 其实在我们的搜索语句中也可以不用包含全部联合索引中的列，只包含左边的就行，比方说下边的查询语句：
        <br>`SELECT * FROM person_info WHERE name = 'Ashburn';`
        <br>或者包含多个左边的列也行：
        <br>`SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday = '1990-09-27';`
        <br>那为什么搜索条件中必须出现左边的列才可以使用到这个 B+ 树索引呢？比如下边的语句就用不到这个 B+ 树索引么？
        <br>`SELECT * FROM person_info WHERE birthday = '1990-09-27';`
        <br><br>是的，的确用不到，因为 B+ 树的数据页和记录先是按照 name 列的值排序的，在 name 列的值相同的情况下才使用 birthday 列进行排序，也就是说 name 列的值不同的记录中 birthday 的值可能是无序的。而现在你跳过name 列直接根据 birthday 的值去查找，臣妾做不到呀～ 那如果我就想在只使用 birthday 的值去通过 B+ 树索引进行查找咋办呢？这好办，你再对 birthday 列建一个 B+ 树索引就行了，创建索引的语法不用我唠叨了吧。
        <br><br>但是需要特别注意的一点是，<span style='color: blue'>如果我们想使用联合索引中尽可能多的列，搜索条件中的各个列必须是联合索引中从最左边连续的列</span>。比方说联合索引 idx_name_birthday_phone_number 中列的定义顺序是 name 、birthday 、 phone_number ，如果我们的搜索条件中只有 name 和 phone_number ，而没有中间的 birthday ，比方说这样：
        <br>`SELECT * FROM person_info WHERE name = 'Ashburn' AND phone_number = '15123983239';`
        <br><br>这样只能用到 name 列的索引， birthday 和 phone_number 的索引就用不上了，因为 name 值相同的记录先按照birthday 的值进行排序， birthday 值相同的记录才按照 phone_number 值进行排序。

    + ### 3.匹配列前缀

        > [?] 我们前边说过为某个列建立索引的意思其实就是在对应的 B+ 树的记录中使用该列的值进行排序，比方说person_info 表上建立的联合索引 idx_name_birthday_phone_number 会先用 name 列的值进行排序，所以这个联合索引对应的 B+ 树中的记录的 name 列的排列就是这样的：
        <br>Aaron，Aaron，...，Aaron，Asa，Ashburn，...，Ashburn，Baird，Barlow，...，Barlow
        <br><br>字符串排序的本质就是比较哪个字符串大一点儿，哪个字符串小一点，比较字符串大小就用到了该列的字符集和比较规则，这个我们前边儿唠叨过，就不多唠叨了。这里需要注意的是，一般的比较规则都是逐个比较字符的大小，也就是说我们比较两个字符串的大小的过程其实是这样的：
        <br>`1).` 先比较字符串的第一个字符，第一个字符小的那个字符串就比较小。
        <br>`2).` 如果两个字符串的第一个字符相同，那就再比较第二个字符，第二个字符比较小的那个字符串就比较小。
        <br>`3).` 如果两个字符串的第二个字符也相同，那就接着比较第三个字符，依此类推。
        <br><br>所以一个排好序的字符串列其实有这样的特点：
        <br>`1).` 先按照字符串的第一个字符进行排序。
        <br>`2).` 如果第一个字符相同再按照第二个字符进行排序。
        <br>`3).` 如果第二个字符相同再按照第三个字符进行排序，依此类推。
        <br><br>也就是说这些字符串的前n个字符，也就是前缀都是排好序的，所以对于字符串类型的索引列来说，我们只匹配它的前缀也是可以快速定位记录的，比方说我们想查询名字以 'As' 开头的记录，那就可以这么写查询语句：
        <br>`SELECT * FROM person_info WHERE name LIKE 'As%';`
        <br><br>但是需要注意的是，如果只给出后缀或者中间的某个字符串，比如这样：
        <br>`SELECT * FROM person_info WHERE name LIKE '%As%';`

        > [!NOTE] MySQL 就无法快速定位记录位置了，因为字符串中间有 'As' 的字符串并没有排好序，所以只能全表扫描了。有时候我们有一些匹配某些字符串后缀的需求，比方说某个表有一个 url 列，该列中存储了许多url：
        <br>![](/.images/doc/framework/mysql/book/07_B+tree_index_ues/btiu-02.png ':size=40%')
        <br>假设已经对该 url 列创建了索引，如果我们想查询以 com 为后缀的网址的话可以这样写查询条件： WHERE url LIKE '%com' ，但是这样的话无法使用该 url 列的索引。为了在查询时用到这个索引而不至于全表扫描，我们可以把后缀查询改写成前缀查询，不过我们就得把表中的数据全部逆序存储一下，也就是说我们可以这样保存 url列中的数据：
        <br><br>这样再查找以 com 为后缀的网址时搜索条件便可以这么写： WHERE url LIKE 'moc%' ，这样就可以用到索引了。

    + ### 4.匹配范围值

        > [?] 回头看我们 idx_name_birthday_phone_number 索引的 B+ 树示意图，<span style='color: blue'>所有记录都是按照索引列的值从小到大的顺序排好序的</span>，所以这极大的方便我们查找索引列的值在某个范围内的记录。比方说下边这个查询语句：
        <br>`SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow';`
        <br><br>由于 B+ 树中的数据页和记录是先按 name 列排序的，所以我们上边的查询过程其实是这样的：
        <br>`1).` 找到 name 值为 Asa 的记录。
        <br>`2).` 找到 name 值为 Barlow 的记录。
        <br>`3).` 哦啦，由于所有记录都是由链表连起来的（记录之间用单链表，数据页之间用双链表），所以他们之间的记录都可以很容易的取出来喽～
        <br>`4).` 找到这些记录的主键值，再到 聚簇索引 中 回表 查找完整的记录。
        <br><br>不过在使用联合进行范围查找的时候需要注意，<span style='color: blue'>如果对多个列同时进行范围查找的话，只有对索引最左边的那个列进行范围查找的时候才能用到 B+ 树索引</span>，比方说这样：
        <br>`SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow' AND birthday > '1980-01-01';`
        <br><br>上边这个查询可以分成两个部分：
        <br>`1).` 通过条件 name > 'Asa' AND name < 'Barlow' 来对 name 进行范围，查找的结果可能有多条 name 值不同的记录，
        <br>`2).` 对这些 name 值不同的记录继续通过 birthday > '1980-01-01' 条件继续过滤。
        <br><br>这样子对于联合索引 idx_name_birthday_phone_number 来说，只能用到 name 列的部分，而用不到 birthday 列的部分，因为只有 name 值相同的情况下才能用 birthday 列的值进行排序，而这个查询中<span style='color: blue'>通过 name 进行范围查找的记录中可能并不是按照 birthday 列进行排序的</span>，所以在搜索条件中继续以 birthday 列进行查找时是用不到这个 B+ 树索引的。

    + ### 5.精确匹配某一列并范围匹配另外一列

        > [?] 对于同一个联合索引来说，虽然对多个列都进行范围查找时只能用到最左边那个索引列，但是如果左边的列是精确查找，则右边的列可以进行范围查找，比方说这样：
        <br>`SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday > '1980-01-01' AND birthday < '2000-12-31' AND phone_number > '15100000000';`
        <br><br>这个查询的条件可以分为3个部分：
        <br>`1).` name = 'Ashburn' ，对 name 列进行精确查找，当然可以使用 B+ 树索引了。
        <br>`2).` birthday > '1980-01-01' AND birthday < '2000-12-31' ，由于 name 列是精确查找，所以通过 name = 'Ashburn' 条件查找后得到的结果的 name 值都是相同的，它们会再按照 birthday 的值进行排序。所以此时对 birthday 列进行范围查找是可以用到 B+ 树索引的。
        <br>`3).` phone_number > '15100000000' ，通过 birthday 的范围查找的记录的 birthday 的值可能不同，所以这个条件无法再利用 B+ 树索引了，只能遍历上一步查询得到的记录。
        <br><br>同理，下边的查询也是可能用到这个 idx_name_birthday_phone_number 联合索引的：
        <br>`SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday = '1980-01-01' AND AND phone_number > '15100000000';`

    + ### 6.用于排序

        > [?] 我们在写查询语句的时候经常需要对查询出来的记录通过 ORDER BY 子句按照某种规则进行排序。一般情况下，我们只能把记录都加载到内存中，再用一些排序算法，比如快速排序、归并排序、吧啦吧啦排序等等在内存中对这些记录进行排序，有的时候可能查询的结果集太大以至于不能在内存中进行排序的话，还可能暂时借助磁盘的空间来存放中间结果，排序操作完成后再把排好序的结果集返回到客户端。在 MySQL 中，把这种在内存中或者磁盘上进行排序的方式统称为文件排序（英文名： filesort ），跟 文件 这个词儿一沾边儿，就显得这些排序操作非常慢了（磁盘和内存的速度比起来，就像是飞机和蜗牛的对比）。但是如果 ORDER BY 子句里使用到了我们的索引列，就有可能省去在内存或文件中排序的步骤，比如下边这个简单的查询语句：
        <br>`SELECT * FROM person_info ORDER BY name, birthday, phone_number LIMIT 10;`
        <br><br>这个查询的结果集需要先按照 name 值排序，如果记录的 name 值相同，则需要按照 birthday 来排序，如果birthday 的值相同，则需要按照 phone_number 排序。大家可以回过头去看我们建立的idx_name_birthday_phone_number 索引的示意图，因为这个 B+ 树索引本身就是按照上述规则排好序的，所以直接从索引中提取数据，然后进行 回表 操作取出该索引中不包含的列就好了。简单吧？是的，索引就是这么牛逼。

        - #### 使用联合索引进行排序注意事项

            > [!NOTE] 对于 联合索引 有个问题需要注意， ORDER BY 的子句后边的列的顺序也必须按照索引列的顺序给出，如果给出ORDER BY phone_number, birthday, name 的顺序，那也是用不了 B+ 树索引，这种颠倒顺序就不能使用索引的原因我们上边详细说过了，这就不赘述了。
            <br><br>同理， ORDER BY name 、 ORDER BY name, birthday 这种匹配索引左边的列的形式可以使用部分的 B+ 树索引。当联合索引左边列的值为常量，也可以使用后边的列进行排序，比如这样：
            <br>`SELECT * FROM person_info WHERE name = 'A' ORDER BY birthday, phone_number LIMIT 10;`
            <br><br>这个查询能使用联合索引进行排序是因为 name 列的值相同的记录是按照 birthday , phone_number 排序的，说了好多遍了都。

        - #### 不可以使用索引进行排序的几种情况

            1. **ASC、DESC混用** 

                > [?] 对于使用联合索引进行排序的场景，我们要求各个排序列的排序顺序是一致的，也就是要么各个列都是 ASC 规则排序，要么都是 DESC 规则排序。<span style='color: blue'>小贴士：ORDER BY子句后的列如果不加ASC或者DESC默认是按照ASC排序规则排序的，也就是升序排序的</span>。为啥会有这种奇葩规定呢？
                <br><br>这个还得回头想想这个 idx_name_birthday_phone_number 联合索引中记录的结构：
                <br>`1).` 先按照记录的 name 列的值进行升序排列。
                <br>`2).` 如果记录的 name 列的值相同，再按照 birthday 列的值进行升序排列。
                <br>`3).` 如果记录的 birthday 列的值相同，再按照 phone_number 列的值进行升序排列。
                <br><br>如果查询中的各个排序列的排序顺序是一致的，比方说下边这两种情况：
                <br>`ORDER BY name, birthday LIMIT 10;`这种情况直接从索引的最左边开始往右读10行记录就可以了。
                <br>`ORDER BY name DESC, birthday DESC LIMIT 10;`这种情况直接从索引的最右边开始往左读10行记录就可以了。
                <br><br>但是如果我们查询的需求是先按照 name 列进行升序排列，再按照 birthday 列进行降序排列的话，比如说这样的查询语句：
                <br>`SELECT * FROM person_info ORDER BY name, birthday DESC LIMIT 10;`
                <br><br>这样如果使用索引排序的话过程就是这样的：
                <br>`1).` 先从索引的最左边确定 name 列最小的值，然后找到 name 列等于该值的所有记录，然后从 name 列等于该值的最右边的那条记录开始往左找10条记录。
                <br>`2).` 如果 name 列等于最小的值的记录不足10条，再继续往右找 name 值第二小的记录，重复上边那个过程，直到找到10条记录为止。
                <br><br>累不累？累！重点是这样不能高效使用索引，而要采取更复杂的算法去从索引中取数据，设计 MySQL 的大叔觉得这样还不如直接文件排序来的快，所以就规定使用联合索引的各个排序列的排序顺序必须是一致的。

            2. **WHERE子句中出现非排序使用到的索引列**

                > [?] 如果WHERE子句中出现了非排序使用到的索引列，那么排序依然是使用不到索引的，比方说这样：
                <br>`SELECT * FROM person_info WHERE country = 'China' ORDER BY name LIMIT 10;`
                <br><br>这个查询只能先把符合搜索条件 country = 'China' 的记录提取出来后再进行排序，是使用不到索引。注意和下边这个查询作区别：
                <br>`SELECT * FROM person_info WHERE name = 'A' ORDER BY birthday, phone_number LIMIT 10;`
                <br><br>虽然这个查询也有搜索条件，但是 name = 'A' 可以使用到索引 idx_name_birthday_phone_number ，而且过滤剩下的记录还是按照 birthday 、 phone_number 列排序的，所以还是可以使用索引进行排序的。

            3. **排序列包含非同一个索引的列**

                > [?] 有时候用来排序的多个列不是一个索引里的，这种情况也不能使用索引进行排序，比方说：
                <br>`SELECT * FROM person_info ORDER BY name, country LIMIT 10;`
                <br><br>name 和 country 并不属于一个联合索引中的列，所以无法使用索引进行排序，至于为啥我就不想再唠叨了，自己用前边的理论自己捋一捋把～

            4. **排序列使用了复杂的表达式**

                > [?] 要想使用索引进行排序操作，必须保证索引列是以单独列的形式出现，而不是修饰过的形式，比方说这样：
                <br>`SELECT * FROM person_info ORDER BY UPPER(name) LIMIT 10;`
                <br><br>使用了 UPPER 函数修饰过的列就不是单独的列啦，这样就无法使用索引进行排序啦。

    + ### 7.用于分组

        > [?] 有时候我们为了方便统计表中的一些信息，会把表中的记录按照某些列进行分组。比如下边这个分组查询：
        <br>`SELECT name, birthday, phone_number, COUNT(*) FROM person_info GROUP BY name, birthday, phone_number;`
        <br><br>这个查询语句相当于做了3次分组操作：
        <br>`1).` 先把记录按照 name 值进行分组，所有 name 值相同的记录划分为一组。
        <br>`2).` 将每个 name 值相同的分组里的记录再按照 birthday 的值进行分组，将 birthday 值相同的记录放到一个小分组里，所以看起来就像在一个大分组里又化分了好多小分组。
        <br>`3).` 再将上一步中产生的小分组按照 phone_number 的值分成更小的分组，所以整体上看起来就像是先把记录分成一个大分组，然后把 大分组 分成若干个 小分组 ，然后把若干个 小分组 再细分成更多的 小小分组 。
        <br><br>然后针对那些 小小分组 进行统计，比如在我们这个查询语句中就是统计每个 小小分组 包含的记录条数。如果没有索引的话，这个分组过程全部需要在内存里实现，而如果有了索引的话，恰巧这个分组顺序又和我们的 B+ 树中的索引列的顺序是一致的，而我们的 B+ 树索引又是按照索引列排好序的，这不正好么，所以可以直接使用
        B+ 树索引进行分组。
        <br><br>和使用 B+ 树索引进行排序是一个道理，分组列的顺序也需要和索引列的顺序一致，也可以只使用索引列中左边的列进行分组，吧啦吧啦的～
    
* ## 回表的代价
    + ### 覆盖索引
* ## 如何挑选索引
    + ### 只为用于搜索、排序或分组的列创建索引
    + ### 考虑列的基数
    + ### 索引列的类型尽量小
    + ### 索引字符串值的前缀
    + ### 让索引列在比较表达式中单独出现
    + ### 主键插入顺序
    + ### 冗余和重复索引